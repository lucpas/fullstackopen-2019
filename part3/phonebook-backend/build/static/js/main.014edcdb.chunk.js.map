{"version":3,"sources":["services/services.js","components/Filter.js","components/PersonForm.js","components/Persons.js","components/Notification.js","App.js","serviceWorker.js","index.js"],"names":["baseURL","callback","axios","get","then","response","data","catch","error","console","log","person","post","put","id","delete","Filter","props","onChange","PersonForm","onSubmit","onAddPerson","onNameChange","onNumberChange","type","Persons","persons","map","key","name","number","onClick","onDeletePerson","Notification","className","msg","App","useState","setPersons","newName","setNewName","newNumber","setNewNumber","filter","setFilter","show","notification","setNotification","useEffect","services","addPersonHandler","event","newPerson","showNotification","err","updatePersonHandler","prompt","window","confirm","p","setTimeout","filteredPersons","toLowerCase","includes","target","value","preventDefault","existingPerson","find","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.014edcdb.chunk.js","sourcesContent":["import axios from 'axios';\r\n\r\nconst baseURL = 'http://localhost:3001/api/persons/';\r\n//const baseURL = 'https://fierce-mesa-26455.herokuapp.com/api/persons/'\r\n// const baseURL = '/api/persons/'\r\n\r\nconst fetchPersons = callback => {\r\n  axios\r\n    .get(baseURL)\r\n    .then(response => callback(response.data))\r\n    .catch(error => console.log(error));\r\n};\r\n\r\nconst storePerson = person => {\r\n  return axios\r\n    .post(baseURL, person)\r\n    .then(response => response.data)\r\n};\r\n\r\nconst updatePerson = person => {\r\n  return axios\r\n    .put(baseURL + person.id, person)\r\n    .then(response => response.data)\r\n};\r\n\r\nconst deletePerson = person => {\r\n  return axios\r\n    .delete(baseURL + person.id)\r\n    .then(response => response.data)\r\n};\r\n\r\nexport default { fetchPersons, storePerson, updatePerson, deletePerson };\r\n","import React from 'react';\r\n\r\nconst Filter = props => {\r\n  return (\r\n    <div>\r\n      filter shown with\r\n      <input onChange={props.onChange} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Filter;\r\n","import React from 'react';\r\n\r\nconst PersonForm = props => {\r\n  return (\r\n    <form onSubmit={props.onAddPerson}>\r\n      <div>\r\n        name: <input onChange={props.onNameChange} />\r\n      </div>\r\n      <div>\r\n        number: <input onChange={props.onNumberChange} />\r\n      </div>\r\n      <div>\r\n        <button type='submit'>add</button>\r\n      </div>\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default PersonForm;\r\n","import React from 'react';\r\n\r\nconst Persons = props => {\r\n  const persons = props.persons.map(person => (\r\n    <p key={person.name}>\r\n      {person.name} {person.number}\r\n      <button onClick={() => props.onDeletePerson(person)}>delete</button>\r\n    </p>\r\n  ));\r\n\r\n  return persons;\r\n};\r\n\r\nexport default Persons;\r\n","import React from 'react'\r\n\r\nimport './Notification.css'\r\n\r\nconst Notification = (props) => {\r\n    return (\r\n        <div className={props.type}>\r\n            {props.msg}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Notification\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport services from './services/services';\r\nimport Filter from './components/Filter';\r\nimport PersonForm from './components/PersonForm';\r\nimport Persons from './components/Persons';\r\nimport Notification from './components/Notification';\r\n\r\nconst App = () => {\r\n  const [persons, setPersons] = useState([]);\r\n  const [newName, setNewName] = useState('');\r\n  const [newNumber, setNewNumber] = useState('');\r\n  const [filter, setFilter] = useState('');\r\n  const [notification, setNotification] = useState({\r\n    show: false,\r\n    msg: '',\r\n    type: null\r\n  });\r\n\r\n  useEffect(() => services.fetchPersons(setPersons), []);\r\n\r\n  // ------------ Person handlers start -----------------------------------------\r\n  const modifyPersonsHandler = event => {\r\n    event.preventDefault();\r\n\r\n    const existingPerson = persons.find(person => person.name === newName);\r\n    if (existingPerson) {\r\n      updatePersonHandler(existingPerson);\r\n    } else {\r\n      addPersonHandler();\r\n    }\r\n  };\r\n\r\n  const addPersonHandler = event => {\r\n    services\r\n      .storePerson({\r\n        name: newName,\r\n        number: newNumber\r\n      })\r\n      .then(newPerson => {\r\n        setPersons([...persons, newPerson]);\r\n        showNotification(`Added ${newPerson.name}`, 'success');\r\n      })\r\n      .catch(err => showNotification(err.response.data.error, 'error'));\r\n  };\r\n\r\n  const updatePersonHandler = person => {\r\n    const prompt = `${person.name} is already added to phonebook, replace the old number with a new one?`;\r\n    if (!window.confirm(prompt)) {\r\n      return;\r\n    }\r\n\r\n    services\r\n      .updatePerson({ ...person, number: newNumber })\r\n      .then(newPerson => {\r\n        setPersons(persons.map(p => (p.id !== newPerson.id ? p : newPerson)));\r\n        showNotification(`Updated ${newPerson.name}`, 'success');\r\n      })\r\n\r\n      .catch(err => showNotification(`error while updating person!`, 'error'));\r\n  };\r\n\r\n  const deletePersonHandler = person => {\r\n    if (!window.confirm(`Delete ${person.name}?`)) {\r\n      return;\r\n    }\r\n\r\n    services\r\n      .deletePerson(person)\r\n      .then(() => {\r\n        setPersons(persons.filter(p => p.id !== person.id));\r\n        showNotification(`Deleted ${person.name}`, 'success');\r\n      })\r\n      .catch(err => showNotification(`error while deleting person!`, 'error'));\r\n  };\r\n  // ------------ Person handlers end -------------------------------------------\r\n\r\n  const showNotification = (msg, type) => {\r\n    setNotification({ show: true, msg, type });\r\n    setTimeout(() => {\r\n      setNotification({ ...notification, show: false });\r\n    }, 10000);\r\n  };\r\n\r\n  const filteredPersons = persons.filter(person =>\r\n    person.name.toLowerCase().includes(filter.toLowerCase())\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <h2>Phonebook</h2>\r\n      {notification.show ? <Notification {...notification} /> : null}\r\n      <Filter onChange={event => setFilter(event.target.value)} />\r\n      <h2>add a new</h2>\r\n      <PersonForm\r\n        onAddPerson={modifyPersonsHandler}\r\n        onNameChange={event => setNewName(event.target.value)}\r\n        onNumberChange={event => setNewNumber(event.target.value)}\r\n      />\r\n      <h2>Numbers</h2>\r\n      <Persons persons={filteredPersons} onDeletePerson={deletePersonHandler} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}